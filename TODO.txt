cycles in resolveChain

smart update in resolveChain?
I.e. as we get resolve chain, we update it

type of subexpressions for if branches
only ML equal type
what if typeof(e2) = 'a
and typeof(e3) = ''a
unify??
Although if the two expression sub-branches were of the same (non-identical, i.e. string representation) type variables, 
they could be still equal, (by generating more constraints), we do not consider this at the moment. 
For example if e_2 was of type ''a, and e_3 was of type '''a, 
we could say that the result type of the if expression is Int, (with mapping ''a→Int,^''' a→Int).

narrow(e1 op e2,arithtypevar)

narrow(e1 = e2) calculating narrowtype

prettyPrintConfig(narrowExpr(BoolExpr(EQ,Value(va'),Value(vb''')),Bool,[],[],[]));		
(* v[''a0] = 1, [ v['a]->v[''a0], v['''b]->1 ], ['a->''a0, '''b->Int, ''a0->Int] *)
(* TO CHECK *)

prettyPrintConfig(narrowExpr(
	Case(ExpressionPair(Value(va'),Value(vb')),VariablePair(Var("x"),Var("y")),
		 ArithExpr(PLUS,Variable(Var("x")),Variable(Var("y")))),Int,[],[],[]));
(* case (1,1) of (x,y) -> x+y, 
  [v['a45] -> 1.0, v['a44] -> 1.0, v['b] -> v['a45], v['a] -> v['a44]]
  ['a45 -> real, 'a44 -> real, 'b -> 'a45, 'a -> 'a44]
  [x -> 1.0, y -> 1.0] *)	
  
 unify update:
 (*
		then (case resolveChainTheta(THole(TypeHole(d)),theta) of
			  THole(_) => THole(TypeHole(d)) (* TO CHECK *)
			| t => t)
	*)
	

unify gnc:
(* if s1<s2 then [(THole(TypeHole(a)), THole(TypeHole(b)))]
					else [(THole(TypeHole(b)), THole(TypeHole(a)))] *)